// 23/07/2014, Alex Kamphuis, a.kamphuis-1@student.utwente.nl, RAM, UTwente

// THIS SHOULD BE RUN IN THE NAMESPACE EQUAL TO THE ROBOT's NAME.

/* ros integration libraries */
	#include "ros/ros.h" // standard ros commands
	#include <ros/console.h> // for console verbosity setting
	

/* required messages */
	#include <ram_vo/robot_state.h>
	#include <ram_vo/VO_summary.h>
	#include "std_msgs/String.h"
	#include "geometry_msgs/Pose.h"
	#include "geometry_msgs/Point.h"

/* math libraries */
//	#include <armadillo> // vecotr algebra
	#include <math.h> // power
//	using namespace arma;

class Control
{
	private:
		/* variables that determine behaviour of the algorithm */
			static const bool CHEAT_OUT_IMAGINARIES = true;
			static const float TSTEP = 0.05; // timestep (optitrack: 100Hz. simulation(gazebo): 1000Hz (set via launchfile--> physics))
			static const float TOLERANCE = 0.15;

		/* Communication with ROS */
			ros::NodeHandle node_handle_; // nodehandle to this node

			ros::Subscriber target_sub_; // subscriber to reciever targets		
			ros::Subscriber info_sub_; // subscriber to recieve info from master divisor
			ros::Publisher setpoint_pub_; // publisher to setpoint for this robot
			ros::Publisher summary_pub_; // publisher for VO summaries for testing
			
			ros::Publisher test_pub_; // publisher to a topic for testing purposes
			//ros::Subscriber position_sub_; // subscriber to position (not used after testing)

		/* info on this robot */
			std::string own_robot_name_;
			float radius_; // radius of this robot
			float vmax_; // maximum velocity (unidirectional) of this robot
			float amax_; // maximum acceleration (unidirectional) of this robot
			static const float STD_YAW = 1;

		/* define structures */
			struct point
			{
				float x; // x position
				float y; // y position
				float z; // z position
			};

			struct point2 // sturcute with 2 points
			{
				point tp1; // location of tangent point
				point tp2; // location of tangent point
			};

			struct VelocityObstacle
			{
				point tp1; // location of tangent point
				point tp2; // location of tangent point
				point a; // own location
			};

			struct LabeledVelocityObstacle // structure to store a velocity obstacle, with name and number of robot causing it
			{
				int robot_number; // number of robot as recieved from divisor
				std::string robot_name; // name of robot as recieved from divisor
				VelocityObstacle VO; // the last calculated velocity obstacle
			};

			struct M3 //3x3 Matrix with floats
			{
				float at11;
				float at12;
				float at13;

				float at21;
				float at22;
				float at23;

				float at31;
				float at32;
				float at33;
			};

			struct other_robot
			{
				int robot_number; // number to identify robot
				std::string robot_name; // name of the robot (and therefore itsnamespace)
				point position; // its position
				point velocity; // its velocity
			};

		/* current state-describers */
			point current_target_, current_position_, current_velocity_, desired_velocity_;

		/* large vectors with info, they form the database/memory */
			std::vector<other_robot> others_;
			std::vector<LabeledVelocityObstacle> VOs_;

	public:
		Control() // constructor
		{
			//ROS_DEBUG("control class made");
			ROS_INFO("Started a VO controller");
			getInfoOnSelf();
				
			/* make a publisher to publish info during testing */
				test_pub_=node_handle_.advertise<std_msgs::String>("test_info",100);

			/* target subscriber */
				target_sub_=node_handle_.subscribe<geometry_msgs::Point>("target",1,&Control::targetCallback,this);			

			/* position subscriber (info generated by optitrack) */
				//position_sub_=node_handle_.subscribe<geometry_msgs::Pose>("unfiltered_pose",100,&Control::positionCallback,this);

			/* get info on other robots */
				// infoCallback calls the update loops
				info_sub_=node_handle_.subscribe<ram_vo::robot_state>("info_from_divisor",1,&Control::infoCallback,this);

			/* setpoint publisher */
				setpoint_pub_=node_handle_.advertise<geometry_msgs::Pose>("setpoint",1);

			/* VO summary publisher for testing purposes */
				summary_pub_ = node_handle_.advertise<ram_vo::VO_summary>("VO_summary",1);
		}
		
		~Control() // destructor
		{
			ROS_WARN("VO_conroller destroyed.");
		}

		void getInfoOnSelf()
		{
			/* get info about this robot and its own position */
				// get own robot name
				own_robot_name_ = ros::this_node::getNamespace();
				// removing the slash at the beginning of the name. I do not know why there is one..
				own_robot_name_ = own_robot_name_.substr(1,own_robot_name_.size()-1);
				// get max velocity and max acceleration and radius
				ROS_INFO_STREAM("this VO_controller controls the robot named "+own_robot_name_);
					/* publish that your getting data */
					 	
					 	ROS_INFO("Waiting 0.5s to let the ROSmaster process advertises");
					 	ros::Duration(0.5).sleep(); // wait for master to process advertise
					 	ROS_INFO("Continueing startup of this VO_controller");
						
					/* get info on self */
					 	ROS_INFO_STREAM("Getting info on self from parameter server...");
						if ( 	ros::param::get("radius",radius_) &&
								ros::param::get("vmax",vmax_) &&
								ros::param::get("amax",amax_) )
						{
							std::stringstream ss;
							ss<<"My radius is: "<<radius_<<"\n"<<
								"my vmax is: "<<vmax_<<"\n"<<
								"my amax is: "<<amax_;
							ROS_INFO_STREAM(ss.str());
						}
						else
						{	
							ROS_FATAL_STREAM("Unable to retrieve vmax, amax and radius from parameter server");
						}

					/* setting initial setpoint */
						ROS_INFO("Getting inital setpoint from parameter server");
						if( (ros::param::get("/control/setpoint_x",current_target_.x)) &&
							(ros::param::get("/control/setpoint_y",current_target_.y)) &&
							(ros::param::get("/control/setpoint_z",current_target_.z))
							)
						{
							ROS_DEBUG_STREAM("Initial setpoint from parameter server:{x= "<<current_target_.x<<
								", y= "<<current_target_.y<<
								", z= "<<current_target_.z<<"}");
						}
						else
						{
							current_target_.x=0;
							current_target_.y=0;
							current_target_.z=1;
							ROS_WARN("Unable to get initial setpoint from parameter server. Setting it {x= 0, y= 0, z=1}");
						}
		}

		void infoCallback(const ram_vo::robot_state::ConstPtr& msg)
		{
			// This is the actual VO update loop

			ROS_DEBUG("Recieved a robot_state info message on /info_from_divisor topic");
			ROS_DEBUG_STREAM("robot name in msg:"<<msg->robot_name<<" own robot name:"<<own_robot_name_);
			if (msg->robot_name==own_robot_name_)
			{
				// message is on this robot
				ROS_DEBUG_STREAM("The info is on myself");

				/* store this robots state */
					// set the position
					current_position_.x=msg->position.x;
					current_position_.y=msg->position.y;
					current_position_.z=msg->position.z;

					// set the velocity
					current_velocity_.x=msg->velocity.x;
					current_velocity_.y=msg->velocity.y;
					current_velocity_.z=msg->velocity.z;
					ROS_DEBUG_STREAM("the current velocity is: "<<normFromStruct3(current_velocity_));

					// only for simulation in plane!!!
					//current_position_.z=1;
					//current_velocity_.z=0;

				ROS_DEBUG("Stored info on myself");

				/* declare variables to make them available for the summary publisher */
					//TO DO: edit this out, variables can be declared on the fly
					point RequestedPosition;
					point RequestedVelocity;
					point newVelocity;
					point AvoidanceVelocity;
				
					ROS_INFO("Calculating avoidance velocity");
				/* set new desired velocity */
					setDesiredVelocity();

				/* pick the new, 'ideal' velocity */
					// ideal meaning if there were no objects/other robots
					newVelocity = pickVelocity();

				/* translate this to a feasible velocity */
					AvoidanceVelocity = pickAvoidanceVelocity(newVelocity);

				/* calculate total required velocity and new position */
					RequestedVelocity = sumStruct3(current_velocity_,AvoidanceVelocity);

					// for testing enlarge the requested velocity
					RequestedVelocity.x*=6.0;
					RequestedVelocity.y*=6.0;
					RequestedVelocity.z*=1.0;

					RequestedPosition = calcNewPos(RequestedVelocity);



				// check if we are near to the target
				float distance_reqpos_to_target = normFromStruct3(diffStruct3(RequestedPosition,current_target_));
				// publish distance to target to test
				std_msgs::String s;
				std::stringstream ss;
				ss<<distance_reqpos_to_target;
				s.data=ss.str();
				test_pub_.publish(s);

				// create message
					geometry_msgs::Pose msg;
				if(distance_reqpos_to_target<=TOLERANCE){
					ROS_INFO_STREAM("RequestedPosition is within: "<<radius_<<" meter of the target");
					ROS_INFO("Checking if target is in a VO");

					bool targetsafe = true; // flag if target is in a velocity obstacle
					for(int VOnr=0;VOnr<VOs_.size();VOnr++)
					{
						LabeledVelocityObstacle tVO = VOs_.at(VOnr);
						if(isInVO(current_target_,tVO))
						{
							targetsafe = false; // notify that target is not safe.
							break; // break for speed
						}
					}

					if(targetsafe)
					{
						ROS_INFO("target is safe, setting it as setpoint");
						// set position
						msg.position.x=current_target_.x;
						msg.position.y=current_target_.y;
						msg.position.z=current_target_.z;	
					}
					else
					{
						ROS_WARN("Target is NOT safe. Setting requested position");

						// set position
						msg.position.x=RequestedPosition.x;
						msg.position.y=RequestedPosition.y;
						msg.position.z=RequestedPosition.z;

						// for testing:
						msg.position.z=1.0;
					}

				}
				else
				{
					ROS_DEBUG("Setting requested position as setpoint");												
					// set position						
					msg.position.x=RequestedPosition.x;
					msg.position.y=RequestedPosition.y;
					msg.position.z=RequestedPosition.z;

					// for testing 
					msg.position.z=1.0; 

				}

				// set orientation
					// (0,0,1) is a rotation about the z axis, so yaw
						// TO DO: experiment with this to check it
					msg.orientation.x=0;
					msg.orientation.y=0;
					msg.orientation.z=0;
					msg.orientation.w=STD_YAW;

				// publish the message
				setpoint_pub_.publish(msg);
				ROS_INFO_STREAM("Publishing new setpoint...");

					/* logging to vo summary for plotting during testing */
						bool log_to_VO_summary = true; // used to easily turn logging on/off
						if (log_to_VO_summary)
						{
							ram_vo::VO_summary summarymsg;							

							if (others_.size()>0 && VOs_.size()>0) // only if theres another robot
							{						

							// position of this robot
							summarymsg.a.x=current_position_.x;
							summarymsg.a.y=current_position_.y;
							summarymsg.a.z=current_position_.z;
							// position of other robot	
							summarymsg.c.x=others_.at(0).position.x;
							summarymsg.c.y=others_.at(0).position.y;
							summarymsg.c.z=others_.at(0).position.z;

							//speed of this robot
							summarymsg.va.x=current_velocity_.x;
							summarymsg.va.y=current_velocity_.y;
							summarymsg.va.z=current_velocity_.z;
							//velocity of other robot
							summarymsg.vc.x=others_.at(0).velocity.x;
							summarymsg.vc.y=others_.at(0).velocity.y;
							summarymsg.vc.z=others_.at(0).velocity.z;
							
							//radii
							summarymsg.ra=radius_;
							float s;
							ros::param::get("/Matteo/radius",s);
							summarymsg.rc=s;

							// tangent points
							summarymsg.tp1.x=VOs_.at(0).VO.tp1.x;
							summarymsg.tp1.y=VOs_.at(0).VO.tp1.y;
							summarymsg.tp1.z=VOs_.at(0).VO.tp1.z;

							summarymsg.tp2.x=VOs_.at(0).VO.tp2.x;
							summarymsg.tp2.y=VOs_.at(0).VO.tp2.y;
							summarymsg.tp2.z=VOs_.at(0).VO.tp2.z;

							summarymsg.apex.x=VOs_.at(0).VO.a.x;
							summarymsg.apex.y=VOs_.at(0).VO.a.y;
							summarymsg.apex.z=VOs_.at(0).VO.a.z;

							summarymsg.target.x=current_target_.x;
							summarymsg.target.y=current_target_.y;
							summarymsg.target.z=current_target_.z;

							summarymsg.desired_velocity.x=desired_velocity_.x;
							summarymsg.desired_velocity.y=desired_velocity_.y;
							summarymsg.desired_velocity.z=desired_velocity_.z;

							summarymsg.difference_velocity.x=newVelocity.x;
							summarymsg.difference_velocity.y=newVelocity.y;
							summarymsg.difference_velocity.z=newVelocity.z;

							summarymsg.avoidance_velocity.x=AvoidanceVelocity.x;
							summarymsg.avoidance_velocity.y=AvoidanceVelocity.y;
							summarymsg.avoidance_velocity.z=AvoidanceVelocity.z;

							summarymsg.requested_velocity.x=RequestedVelocity.x;
							summarymsg.requested_velocity.y=RequestedVelocity.y;
							summarymsg.requested_velocity.z=RequestedVelocity.z;

							summarymsg.requested_position.x=RequestedPosition.x;
							summarymsg.requested_position.y=RequestedPosition.y;
							summarymsg.requested_position.z=RequestedPosition.z;
							}

							summary_pub_.publish(summarymsg);							
							ROS_DEBUG("VO summary published");
						}

			}
			else
			{
				// message is on other robot
				int InfoIsAt;
				/* store the info and calculate a new VO */
					 // it is not strictly necessary to store the info on other robots. we only need to know velocity obstacles. For the sake of completeness i do store and update the info on other robots. the calcVelocityObstacle() function only requires a structe other_robot to run, so giving it info from just the message (in stead of memory) is also very well possible.
					InfoIsAt = storeInfo(msg); // store the info

					/* see if we already have a velocity obstacle for this robot */
					int flag=-1; // flag to see if (and where) we already have a velocity obstacle on this robot

					for (int ii=0; ii<VOs_.size(); ii++) // loop through all VOs
					{
						if (VOs_.at(ii).robot_name==msg->robot_name) // we have a velocity obstacle on this robot
						{
							flag=ii; // save where we fount it
							// never returns -1
						}
					}

					/* calc velocity object */
						VelocityObstacle tVO; //temporary velocity obstacle
						tVO=calcVelocityObstacle(others_.at(InfoIsAt));

						LabeledVelocityObstacle lVO;
						lVO.VO.tp1=tVO.tp1;
						lVO.VO.tp2=tVO.tp2;
						lVO.VO.a=tVO.a;
						// set name and number
						lVO.robot_name=msg->robot_name;
						lVO.robot_number=msg->robot_number;

					if (flag==-1)
					{
						// we have not yet stored a velocity obstacle for this robot
						/* calc a new velocity obstacle and add it to the list */
							// add it to VOs_
							VOs_.push_back(lVO);
					}
					else
					{
						// we have already stored a velocity obstacle for this robot
						/* calc a new velocity obstacle and updat the old one */
							// place it at the correct location in VOs_
							VOs_.at(flag)=lVO;
					}
					ROS_DEBUG_STREAM("The amount of velocity obstacles i have stored is: "<<VOs_.size());
				}
		}

		void targetCallback(const geometry_msgs::Point::ConstPtr& msg)
		{
			// sets the target recieved in msg as this robots current target
			//ROS_DEBUG("Recieved a new target");
			current_target_.x=msg->x;
			current_target_.y=msg->y;
			current_target_.z=msg->z;
			ROS_WARN("Recieved a new target and stored it as new current target");
		}

		void positionCallback(const geometry_msgs::Pose::ConstPtr& msg)
		{
			// can be used for direct position feedback, omitting the master divisor. by default this is not activated.
			ROS_WARN_STREAM("using direct position feedback that ommits the master divisor");
			setCurrentPosition(msg);
			setDesiredVelocity();
		}

		point pickVelocity()
		{
			/* this fucntion picks a velocity that:
				1. points towards the desired velocity
				2. from the current_velocity_
				3. is dynamically feasible (from amax, not necessarily from vmax)
			*/

			/* finding the veloicty direction */
				point dv = diffStruct3(desired_velocity_,current_velocity_); // difference vector

			/* scaling down. this was usefull in matlab simulation without controller,
				to avoid overshoot. disable might be smart during testing */
				float norm = normFromStruct3(dv); // length of dv
				if (norm<=0) // zero catching
				{
					// TO DO: find a way to do this better, or make a good estimation of what to set norm to
					ROS_WARN("Norm of difference vector<=0; setting it to a small positive value");
					norm = 0.00001;
				}
				point ndv; // normalised difference vector (norm=1)
					ndv.x=dv.x/norm;
					ndv.y=dv.y/norm;
					ndv.z=dv.z/norm;
					point mdv; // new velocity vector with max acceleration
					mdv.x=amax_*TSTEP*ndv.x;
					mdv.y=amax_*TSTEP*ndv.y;
					mdv.z=amax_*TSTEP*ndv.z;
			return mdv;
		}

		point pickAvoidanceVelocity(point pv)
		{
			// TO DO: write a rotating deer strategy in 3d
			// TO DO: think of more avoidance strategies?
			/* 
			this function conducts an avoidance strategy and returns the best v.
			According to the strategy this 'best v' might not even be guarenteed to be collision free. 
			*/

			point AvoidanceVelocity;
			std::string AVSTRAT = "rotating_planar_deer"; // set avoidance strategy to use

			// error checking for avoidance strategy input
			// add more strategies if they are defined
			if (!(AVSTRAT=="rotating_planar_deer")||(AVSTRAT=="rotating_deer"))
			{
				ROS_ERROR_STREAM("Avoidance strategy "<<AVSTRAT<<" unknown; using 'rotating_planar_deer' strategy.");
				AVSTRAT="rotating_planar_deer";
			}

			if (AVSTRAT=="rotating_planar_deer")
			{
				/*
				This avoidance strategy works only in the xy plane. it will set all z motions to zero.

				This strategy works by rotating the desired velocity right and left alternatively by a larger angle everytime, untill it has foun a solution.

				if this strategy can not find a solution it will slow down the robot, giving it the same behaviour of as a deer about to be hit on a road: it freezes.
				*/
				ROS_DEBUG("avoiding obstacles using the 'rotating_planar_deer' strategy");

				//pv.z=0; // Set the z-direction to zero.
				
				for (float theta=0.0; theta<M_PI; theta=theta+0.1)
				{
					// this loop runs through a lot of thetas to find a solution that is not in any velocity obstacles. if it can not find one, theta will be pi, meaning the robot is slowing down (in xy plane)

					/* try turning right by angle theta */
						M3 Rot = constructRotmatrixZ(theta);
						point newVelocity = rotateVector(pv,Rot);
						/* make the velocity smaller to fit vmax */
							point diffv;
							if(normFromStruct3(sumStruct3(current_velocity_,newVelocity))>vmax_)
							{
								// the new combined velocity is too large to be dynamically feasible. make it smaller here
								ROS_DEBUG_STREAM("Scaling down velocity vector because it is larger then vmax.");
								point vtemp = sumStruct3(current_velocity_,newVelocity);
								// now make vtemp smaller to fit vmax
								// reshape vtemp
									float norm = normFromStruct3(vtemp);
									vtemp.x=vtemp.x*vmax_/norm;
									vtemp.y=vtemp.y*vmax_/norm;
									vtemp.z=vtemp.z*vmax_/norm;
								// calculate new difference vector
									diffv = diffStruct3(vtemp,current_velocity_);	
							}
							else
							{
								// pass through the new velocity if it is not too large
								diffv = newVelocity;
							}

						/* add velocities to current position */
							point PplusV = sumStruct3(sumStruct3(current_velocity_,current_position_),diffv);

						/* check if this is within any VO */
							bool flag=false; //record if the point is in a velocity obstacle
							for(int ii=0; ii<VOs_.size();ii++)
							{
								//loop through all VOs_
								if(isInVO(PplusV,VOs_.at(ii)))
								{
									flag=true;
									ROS_INFO("IN VO!!!");
									break; // early break for speed
								}
							}
							if(!(flag))
							{
								// the new point is not in a velocity obstacle
								AvoidanceVelocity=diffv; // save this velocity
								break; // break the for loop early for speed
							}

					/* try turning left by angle theta */
						Rot = constructRotmatrixZ(-theta);
						newVelocity = rotateVector(pv,Rot);
						/* make the velocity smaller to fit vmax */
							if(normFromStruct3(sumStruct3(current_velocity_,newVelocity))>vmax_)
							{
								// the new combined velocity is too large to be dynamically feasible. make it smaller here
								point vtemp = sumStruct3(current_velocity_,newVelocity);
								// now make vtemp smaller to fit vmax
								// reshape vtemp
									float norm = normFromStruct3(vtemp);
									vtemp.x=vtemp.x*vmax_/norm;
									vtemp.y=vtemp.y*vmax_/norm;
									vtemp.z=vtemp.z*vmax_/norm;
								// calculate new difference vector
									diffv = diffStruct3(vtemp,current_velocity_);	
							}
							else
							{
								// pass through the new velocity if it is not too large
								diffv = newVelocity;
							}

						/* add velocities to current position */
							PplusV = sumStruct3(sumStruct3(current_velocity_,current_position_),diffv);

						/* check if this is within any VO */
							flag=false; //record if the point is in a velocity obstacle
							for(int ii=0; ii<VOs_.size();ii++)
							{
								//loop through all VOs_
								if(isInVO(PplusV,VOs_.at(ii)))
								{
									flag=true;
									break; // early break for speed
								}
							}
							if(!(flag))
							{
								// the new point is not in a velocity obstacle
								AvoidanceVelocity=diffv; // save this velocity
								break; // break the for loop early for speed
							}	


					/* set AvoidanceVelocity in the case no solution has been found */
						AvoidanceVelocity=diffv; // diffv is still the last used velocity, achieved with theta=pi (at the end of the loop)
				}

				if (pv.z!=0)
				{
					ROS_ERROR_STREAM("pv.z is not zero, something went wrong using the rotating_planar_deer strategy");
				}

				return AvoidanceVelocity;
			}

			if(AVSTRAT=="rotating_deer")
			{
				ROS_FATAL_STREAM("rotating_deer method not yet set");
			}
		}

		VelocityObstacle calcVelocityObstacle(other_robot other)
		{
			/* This function calculates the velocity obstacle of <other_robot> other on this robot */
			ROS_DEBUG_STREAM("calculating a velocity obstacle");

			/* Prepare for algorithm */
				/* load in variable names to conform with matlab algorithm.*/
						// TO DO: replace all this, or make some sort of a dictonary
					point c = other.position; // position of other robot
					point a = current_position_; // position of this robot

				/* calculate the distance between the robots */
					ROS_DEBUG_STREAM("calculating distance between: "<<c.x<<","<<c.y<<","<<c.z<<" and: "<<a.x<<","<<a.y<<","<<a.z);
					
					float d = sqrt(pow(c.x-a.x,2)+pow(c.y-a.y,2)+pow(c.z-a.z,2));
					ROS_DEBUG_STREAM("distance between objects is: "<<d);

				/* enlarge radius of the other robot with radius of own robot */
					ROS_DEBUG_STREAM("getting radius of robot with name: "<<other.robot_name);
					float r; // radius of other robot
					
					if (ros::param::get(other.robot_name+"/radius",r)) // get param and save, send debugstreams to show wether this succeeded
					{
						ROS_DEBUG_STREAM("found radius of robot "<<other.robot_name<<" to be: "<<r);
					}
					else
					{
						ROS_ERROR_STREAM("unable to get radius of robot named: "<<other.robot_name);
					}
					

					r=r+radius_; // update the others radius with my own
					ROS_DEBUG_STREAM("own radius: "<<radius_<<" enhanced radius: "<<r);

				/* cheat out imaginaries if required */
					if (CHEAT_OUT_IMAGINARIES)
					{
						// r>=d occurs when there is a collision or robots are in each others no-fly zone. The algorithm expects r to be smaller then d, and so we lower r a bit.
							// TO DO: write documentation on this method, or find a nicer/better way to solve this problem
						if (r>=d) 
						{
							// TO DO: make a better estimation on how much smaller r should be each iteration
							ROS_WARN_STREAM("making r smaller so that it is smaller then d");
							r=d-0.01;
						}
					}

			/* call parts of the algorithm */
				point2 tps = calcTangentPoints(a,c,r);
				// create a collision cone (by adding own velocity)
				VelocityObstacle CollisionCone; // init Collision Cone
				CollisionCone.tp1=tps.tp1; // add tp1
				CollisionCone.tp2=tps.tp2; // add tp2
				CollisionCone.a=current_position_; // add own position
				VelocityObstacle VO;
				VO = translateTps(CollisionCone,other.velocity);
			return VO;
		}

		point calcNewPos(point velocity)
		{
			/* calculates what point will be achieved if velocity is flewn during the complete timestep */
			point newPos;
			newPos.x=current_position_.x+TSTEP*velocity.x;
			newPos.y=current_position_.y+TSTEP*velocity.y;
			newPos.z=current_position_.z+TSTEP*velocity.z;

			return newPos;
		}

		bool isInVO(point x, LabeledVelocityObstacle lVO)
		{
			// returns true if point x is inside VO
			ROS_DEBUG_STREAM("Checking if a point is in a VO");

			/*
				The velocity obstacle is an infinitely large cone. we know where its apex is: vo.a. Furthermore we can define a base between 2 tangent points. then the axis runs from the apex trhough the base.

				vector v is a vector pointing from  the apex to the point to be tested (x).

				if anglebetween(axis,v)<apertureofcone; x.isinside
			*/
			
			/* calculate cone properties */
				point apex=lVO.VO.a;
				point base;
					base.x=(lVO.VO.tp1.x+lVO.VO.tp2.x)/2;
					base.y=(lVO.VO.tp1.y+lVO.VO.tp2.y)/2;
					base.z=(lVO.VO.tp1.z+lVO.VO.tp2.z)/2;



				point axis;
					axis.x=base.x-apex.x;
					axis.y=base.y-apex.y;
					axis.z=base.z-apex.z;

				// calculate the aperture (angle of the cone)
				float Laxis = normFromStruct3(axis); // length of axis
				point bastetotp;
					bastetotp.x=base.x-lVO.VO.tp1.x;
					bastetotp.y=base.y-lVO.VO.tp1.y;
					bastetotp.z=base.z-lVO.VO.tp1.z;
				float Lbase = normFromStruct3(bastetotp); // radius of base
				float aperture = atan(Lbase/Laxis);

			/* angle between apex-to-x and the axis */
				point v; // vector from apex to x
					v.x=x.x-apex.x;
					v.y=x.y-apex.y;
					v.z=x.z-apex.z;

			/* perform zero catching */
				if(normFromStruct3(v)<=0.05){
					ROS_WARN("The point being tested is very close to the position of the robot");
					ROS_WARN("Pretending it is not in the velocity obstacle");
					bool inside=false;
					return inside;
				}

				float angle;
				angle = acos( (dotStruct3(axis,v)) / (normFromStruct3(axis)*normFromStruct3(v)) );

				bool inside = angle<aperture;

			return inside;
		}

		point2 calcTangentPoints(point a, point c, float r)
		{
			ROS_DEBUG("Calculating tangent points for: ");
			ROS_DEBUG("a is: %f, %f, %f",a.x,a.y,a.z);
			ROS_DEBUG("c is: %f, %f, %f",c.x,c.y,c.z);

			/* Initialize variables for better overview */
				point da, Ra, tp1, tp2;
				float rx, tx, rda, alpha, gamma, offseta, theta, theta2;
				M3 Rx, Rx_inv;

			/* move c to the origin of the axis */
				// if you move c to the origin, you subtract it from itself. then you must also subtract c from a.
				da.x=a.x-c.x;
				da.y=a.y-c.y;
				da.z=a.z-c.z;

			/* projected length as seen perpendicular to yz plane */
				rx=sqrt(pow(da.z,2)+pow(da.y,2));

			/* Rotate around x axis */
				tx = atan2(da.z,da.y); // required rotation
				Rx = constructRotmatrixX(tx); // contstruct rot matrix
				Ra = rotateVector(da,Rx); // perform rotation
				ROS_DEBUG_STREAM("Ra is: "<<Ra.x<<","<<Ra.y<<","<<Ra.z);

			/* calculate angles */
				rda=normFromStruct3(Ra); // projected length
				alpha=asin(r/rda); // angle alpha (between x-axis and a to tp1)
				gamma=0.5*M_PI-alpha;  // angle between tp lines
				// note to myself: M_PI is just pi (3.14...)
				offseta=atan2(Ra.y,Ra.x); // rotation from x-axis
				theta=offseta-gamma;
				theta2=theta+2.0*gamma;

			/* get tangen points using angles */
				// point 1
				tp1.x=r*cos(theta);
				tp1.y=r*sin(theta);
				tp1.z=0;

				// point 2
				tp2.x=r*cos(theta2);
				tp2.y=r*sin(theta2);
				tp2.z=0;

			/* rotate and translate back */
				Rx_inv=constructRotmatrixX(-tx); // contstruct inverse rotation matrix that rotates back
				tp1 = rotateVector(tp1,Rx_inv); // rotate vector tp1 back
				tp2 = rotateVector(tp2,Rx_inv); // rotate vector tp2 back

				//translate tp1 by c
				tp1.x=tp1.x+c.x;
				tp1.y=tp1.y+c.y;
				tp1.z=tp1.z+c.z;

				//translate tp2 by c
				tp2.x=tp2.x+c.x;
				tp2.y=tp2.y+c.y;
				tp2.z=tp2.z+c.z;

			/* output for error checking */ 
				ROS_DEBUG_STREAM("tp1: "<<tp1.x<<","<<tp1.y<<","<<tp1.z<<"\n"<<"tp2: "<<tp2.x<<","<<tp2.y<<","<<tp2.z);

			/* creating output */
				point2 tps;
				tps.tp1 = tp1;
				tps.tp2 = tp2;

			return tps;
		}

		VelocityObstacle translateTps(VelocityObstacle CC, point v)
		{
			/* translate the tangent points in tps by a velocity v, creating velocity obstacle from the collision cone */
				// augmenting tp 1
				CC.tp1.x=CC.tp1.x+v.x;
				CC.tp1.y=CC.tp1.y+v.y;
				CC.tp1.z=CC.tp1.z+v.z;

				// augmenting tp 2
				CC.tp2.x=CC.tp2.x+v.x;
				CC.tp2.y=CC.tp2.y+v.y;
				CC.tp2.z=CC.tp2.z+v.z;

				// augmenting own position
				CC.a.x=CC.a.x+v.x;
				CC.a.y=CC.a.y+v.y;
				CC.a.z=CC.a.z+v.z;

			return CC;
		}

		int storeInfo(const ram_vo::robot_state::ConstPtr& msg)
		{
			// this function stores the info on a robot in memory. it returns the location in others_ where it is stored.


			/* place the info from this robot in memory */
				int robotID = msg->robot_number; // unique ID
				bool foundit=false; // used to flag if robot already is in memory

				//std::stringstream ss;
				//ss<<"got an info message on robot with number: "<<robotID;
				//ROS_INFO_STREAM(ss.str());

				std::stringstream ss;
				ss<<"The info message is on another robot called: "<<msg->robot_name;
				ROS_DEBUG_STREAM(ss.str());
				// this is the state of another robot
				bool flag=false;
				int savedat; // to record where the info was stored
				for (int ii=0;ii<others_.size();ii++)
				{
					int oldID = others_.at(ii).robot_number;
					if (oldID==robotID) // this is info on a robot i already know
					{
						flag=true;

						// setting position
						others_.at(ii).position.x=msg->position.x;
						others_.at(ii).position.y=msg->position.y;
						others_.at(ii).position.z=msg->position.z;

						// setting velocity
						others_.at(ii).velocity.x=msg->velocity.x;
						others_.at(ii).velocity.y=msg->velocity.y;
						others_.at(ii).velocity.z=msg->velocity.z;
						savedat=ii;
					}
				}
				if(!flag) // this is info i do not know yet
				{
					other_robot other;
					other.robot_number=msg->robot_number;
					/* update speed and position */
						// position
						other.position.x=msg->position.x;
						other.position.y=msg->position.y;
						other.position.z=msg->position.z;

						// velocity
						other.velocity.x=msg->velocity.x;
						other.velocity.y=msg->velocity.y;
						other.velocity.z=msg->velocity.z;

					/* saving its name */
						other.robot_name=msg->robot_name;

					/* add to the others_ array */
					others_.push_back(other);
					ROS_INFO_STREAM("the size of others_ is now: "<<others_.size());
					savedat=others_.size()-1;

				}
				ROS_DEBUG_STREAM("Saved info for a robot named: "<<msg->robot_name<<" at others_.at("<<savedat<<")");
			return savedat;
		}

		void setCurrentPosition(const geometry_msgs::Pose::ConstPtr& msg)
		{
			current_position_.x=msg->position.x;
			current_position_.y=msg->position.y;
			current_position_.z=msg->position.z;
		}

		M3 constructRotmatrixX(float t)
		{
			/* constructs a 3d rotation matrix around the x axis achieving a rotation of <t> radians */
			M3 rot; // initialize rotation matrix
			
			/* fill in elements */
				// first row
				rot.at11=1;
				rot.at12=0;
				rot.at13=0;

				// second row
				rot.at21=0;
				rot.at22=cos(t);
				rot.at23=sin(t);

				// third row
				rot.at31=0;
				rot.at32=-sin(t);
				rot.at33=cos(t);

			return rot;
		}

		M3 constructRotmatrixZ(float t)
		{
			/* constructs a 3d rotation matrix around the z axis achieving a rotation of <t> radians */
			M3 rot; // initialize rotation matrix
			
			/* fill in elements */
				// first row
				rot.at11=cos(t);
				rot.at12=sin(t);
				rot.at13=0;

				// second row
				rot.at21=-sin(t);
				rot.at22=cos(t);
				rot.at23=0;

				// third row
				rot.at31=0;
				rot.at32=0;
				rot.at33=1;

			return rot;
		}

		point rotateVector(point v, M3 R)
		{
			/*rotates the vector v by multiplying it with the rotation matrix R*/
			point rv;
			rv.x= v.x*R.at11 + v.y*R.at12 + v.z*R.at13;
			rv.y= v.x*R.at21 + v.y*R.at22 + v.z*R.at23;
			rv.z= v.x*R.at31 + v.y*R.at32 + v.z*R.at33;

			return rv;
		}
		
		float normFromStruct3(point point)
		{
			// Returns the euclidian norm of a structure that includes 3 floats
			float d = sqrt(pow(point.x,2)+pow(point.y,2)+pow(point.z,2));
			return d;
		}

		float dotStruct3(point a, point b)
		{
			// calculates the dotproduct of two points in 3d space, defined by two point structures
			float dp = a.x*b.x+a.y*b.y+a.z*b.z;
			return dp;
		}

		point diffStruct3(point a, point b)
		{
			// point a- point b, elementwise
			point diff;
				diff.x=a.x-b.x;
				diff.y=a.y-b.y;
				diff.z=a.z-b.z;
			return diff;
		}

		point sumStruct3(point a, point b)
		{
			// point a+point b, elementwise
			point sum;
				sum.x=a.x+b.x;
				sum.y=a.y+b.y;
				sum.z=a.z+b.z;
			return sum;
		}

		point setDesiredVelocity()
		{
			/*
				This function picks a velocity pointing from the robot position to its target.

				the velocity is saturated to vmax_
			*/

			/* get direction of desired velocity */
				desired_velocity_.x=current_target_.x-current_position_.x;
				desired_velocity_.y=current_target_.y-current_position_.y;
				desired_velocity_.z=current_target_.z-current_position_.z;

			/* saturate to vmax */
				if (normFromStruct3(desired_velocity_)>vmax_)
				{
					float d=normFromStruct3(desired_velocity_);
					desired_velocity_.x*=(vmax_/d);
					desired_velocity_.y*=(vmax_/d);
					desired_velocity_.z*=(vmax_/d);
				}


			/* old method */
			/*
			/* time needed for descelleration 
				float t_desc = vmax_/amax_; // time to descellerate
				float s_desc = 0.5*amax_*pow(t_desc,2); // space to descellerate
				float d = normFromStruct3(desired_velocity_); // disance to target
			/* used before (but i'm scared to delete) scale velocity to vmax_
				if (d==0)
				{  // catch error for d=0
					d=0.00001;
					ROS_DEBUG("distance to target is zero, reset it to a small value");
				}
				

				float c = vmax_/d;
				desired_velocity_.x=c*desired_velocity_.x;
				desired_velocity_.y=c*desired_velocity_.y;
				desired_velocity_.z=c*desired_velocity_.z;

			/* used before (but i'm scared to delete) make scale velocity to distance to target 
				if (d<=s_desc) 
				{
					// do not need zero catching for s_desc because it follows from amax and vmax..
					float ds=d/s_desc; // factor to scale with
					desired_velocity_.x=ds*desired_velocity_.x;
					desired_velocity_.y=ds*desired_velocity_.y;
					desired_velocity_.z=ds*desired_velocity_.z;
				}
			*/

				/*std::stringstream ss;
				ss<<"the preffered velocity consistst of: \n"
				<<"x: "<<desired_velocity_.x<<"\n"
				<<"y: "<<desired_velocity_.y<<"\n"
				<<"z: "<<desired_velocity_.z;

				std_msgs::String msg;
				msg.data=ss.str();

				test_pub_ = node_handle_.advertise<std_msgs::String>("test_info",100);
				test_pub_.publish(msg);*/
		}

		void publishAllOthers() //unused
		{
			std::stringstream sa;
			sa<<"i know of "<< others_.size() <<"others";
			ROS_DEBUG_STREAM(sa.str());

			for (int ii=0;ii<others_.size();ii++)
			{
				std::stringstream ss;
				other_robot other = others_.at(ii);
				ss<<"ID: "<<other.robot_number<<"\n"<<
					"position: "<<other.position.x<<","<<other.position.y<<","<<other.position.z<<"\n"<<
					"speed: "<<other.velocity.x<<","<<other.velocity.y<<","<<other.velocity.z;
				std_msgs::String msg;
				msg.data=ss.str();
				//test_pub_.publish(msg);
			}
		}
};


int main(int argc, char **argv)
{
	/* initialize the ROSnode */
	ros::init(argc, argv, "VO_controller");

	/*set verbosity levels to debug */
		/*
		if( ros::console::set_logger_level(ROSCONSOLE_DEFAULT_NAME, ros::console::levels::Debug) )
		{
	   		ros::console::notifyLoggerLevelsChanged();
		}
		*/

	/* start the velocity controller */
	ROS_INFO("initializing VO_controller");
	Control control;

	/* spin to process callbacks etc. */
		// TO DO: read more on when/how/why to use spin/spinonce etc.
	ros::spin();
	
	return 0;
}